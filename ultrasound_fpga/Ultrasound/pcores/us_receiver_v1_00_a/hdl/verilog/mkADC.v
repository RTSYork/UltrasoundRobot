//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Fri Aug  2 18:55:58 BST 2013
//
// Method conflict info:
// Method: init
// Conflict-free: readTemp, readSample, adc, miso, sck, mosi
// Sequenced after: ss
// Conflicts: init, requestTemp, requestSample
//
// Method: requestTemp
// Conflict-free: adc, miso, sck, mosi
// Sequenced after: ss
// Sequenced after (restricted): readTemp, readSample
// Conflicts: init, requestTemp, requestSample
//
// Method: requestSample
// Conflict-free: adc, miso, sck, mosi
// Sequenced after: ss
// Sequenced after (restricted): readTemp, readSample
// Conflicts: init, requestTemp, requestSample
//
// Method: readTemp
// Conflict-free: init, readSample, adc, miso, sck, mosi, ss
// Sequenced before (restricted): requestTemp, requestSample
// Conflicts: readTemp
//
// Method: readSample
// Conflict-free: init, readTemp, adc, miso, sck, mosi, ss
// Sequenced before (restricted): requestTemp, requestSample
// Conflicts: readSample
//
// Method: adc
// Conflict-free: init,
// 	       requestTemp,
// 	       requestSample,
// 	       readTemp,
// 	       readSample,
// 	       miso,
// 	       sck,
// 	       mosi
// Sequenced before (restricted): adc
// Sequenced after (restricted): ss
//
// Method: miso
// Conflict-free: init,
// 	       requestTemp,
// 	       requestSample,
// 	       readTemp,
// 	       readSample,
// 	       adc,
// 	       sck,
// 	       mosi,
// 	       ss
// Sequenced before (restricted): miso
//
// Method: sck
// Conflict-free: init,
// 	       requestTemp,
// 	       requestSample,
// 	       readTemp,
// 	       readSample,
// 	       adc,
// 	       miso,
// 	       sck,
// 	       mosi,
// 	       ss
//
// Method: mosi
// Conflict-free: init,
// 	       requestTemp,
// 	       requestSample,
// 	       readTemp,
// 	       readSample,
// 	       adc,
// 	       miso,
// 	       sck,
// 	       mosi,
// 	       ss
//
// Method: ss
// Conflict-free: readTemp, readSample, miso, sck, mosi, ss
// Sequenced before: init, requestTemp, requestSample
// Sequenced before (restricted): adc
//
//
// Ports:
// Name                         I/O  size props
// RDY_init                       O     1
// RDY_requestTemp                O     1
// RDY_requestSample              O     1
// readTemp                       O    16 reg
// RDY_readTemp                   O     1
// readSample                     O    16 reg
// RDY_readSample                 O     1
// sck                            O     1 reg
// mosi                           O     1 reg
// ss                             O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// requestSample_sensor           I     8
// adc_done                       I     1 reg
// miso_val                       I     1 reg
// EN_init                        I     1
// EN_requestTemp                 I     1
// EN_requestSample               I     1
// EN_readTemp                    I     1
// EN_readSample                  I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkADC(CLK,
	     RST_N,

	     EN_init,
	     RDY_init,

	     EN_requestTemp,
	     RDY_requestTemp,

	     requestSample_sensor,
	     EN_requestSample,
	     RDY_requestSample,

	     EN_readTemp,
	     readTemp,
	     RDY_readTemp,

	     EN_readSample,
	     readSample,
	     RDY_readSample,

	     adc_done,

	     miso_val,

	     sck,

	     mosi,

	     ss);
  input  CLK;
  input  RST_N;

  // action method init
  input  EN_init;
  output RDY_init;

  // action method requestTemp
  input  EN_requestTemp;
  output RDY_requestTemp;

  // action method requestSample
  input  [7 : 0] requestSample_sensor;
  input  EN_requestSample;
  output RDY_requestSample;

  // actionvalue method readTemp
  input  EN_readTemp;
  output [15 : 0] readTemp;
  output RDY_readTemp;

  // actionvalue method readSample
  input  EN_readSample;
  output [15 : 0] readSample;
  output RDY_readSample;

  // action method adc
  input  adc_done;

  // action method miso
  input  miso_val;

  // value method sck
  output sck;

  // value method mosi
  output mosi;

  // value method ss
  output ss;

  // signals for module outputs
  wire [15 : 0] readSample, readTemp;
  wire RDY_init,
       RDY_readSample,
       RDY_readTemp,
       RDY_requestSample,
       RDY_requestTemp,
       mosi,
       sck,
       ss;

  // register adcDone
  reg adcDone;
  wire adcDone$D_IN, adcDone$EN;

  // register data
  reg [15 : 0] data;
  reg [15 : 0] data$D_IN;
  wire data$EN;

  // register hasSample
  reg hasSample;
  wire hasSample$D_IN, hasSample$EN;

  // register hasTemp
  reg hasTemp;
  wire hasTemp$D_IN, hasTemp$EN;

  // register initialising
  reg initialising;
  wire initialising$D_IN, initialising$EN;

  // register readState
  reg [1 : 0] readState;
  reg [1 : 0] readState$D_IN;
  wire readState$EN;

  // register readingSample
  reg readingSample;
  wire readingSample$D_IN, readingSample$EN;

  // register readingTemp
  reg readingTemp;
  wire readingTemp$D_IN, readingTemp$EN;

  // ports of submodule spi
  reg [7 : 0] spi$startSendRead_data;
  wire [7 : 0] spi$readByte;
  wire spi$EN_readByte,
       spi$EN_startRead,
       spi$EN_startSendRead,
       spi$RDY_readByte,
       spi$RDY_startRead,
       spi$RDY_startSendRead,
       spi$busy,
       spi$miso_val,
       spi$mosi,
       spi$sck,
       spi$ss;

  // rule scheduling signals
  wire WILL_FIRE_RL_initDone,
       WILL_FIRE_RL_sampleDone1,
       WILL_FIRE_RL_sampleDone2,
       WILL_FIRE_RL_sampleDone3,
       WILL_FIRE_RL_sampleDone4,
       WILL_FIRE_RL_tempDone1,
       WILL_FIRE_RL_tempDone2,
       WILL_FIRE_RL_tempDone3,
       WILL_FIRE_RL_tempDone4;

  // inputs to muxes for submodule ports
  wire [15 : 0] MUX_data$write_1__VAL_1,
		MUX_data$write_1__VAL_2,
		MUX_data$write_1__VAL_3,
		MUX_data$write_1__VAL_4;
  wire [7 : 0] MUX_spi$startSendRead_1__VAL_1;
  wire MUX_readState$write_1__SEL_1,
       MUX_readState$write_1__SEL_2,
       MUX_readState$write_1__SEL_3,
       MUX_readState$write_1__SEL_4;

  // action method init
  assign RDY_init = RDY_requestSample ;

  // action method requestTemp
  assign RDY_requestTemp = RDY_requestSample ;

  // action method requestSample
  assign RDY_requestSample =
	     !initialising && !readingTemp && !readingSample &&
	     spi$RDY_startSendRead ;

  // actionvalue method readTemp
  assign readTemp = data ;
  assign RDY_readTemp = hasTemp && !readingTemp ;

  // actionvalue method readSample
  assign readSample = data ;
  assign RDY_readSample = hasSample && !readingSample ;

  // value method sck
  assign sck = spi$sck ;

  // value method mosi
  assign mosi = spi$mosi ;

  // value method ss
  assign ss = spi$ss ;

  // submodule spi
  mkSPI spi(.CLK(CLK),
	    .RST_N(RST_N),
	    .miso_val(spi$miso_val),
	    .startSendRead_data(spi$startSendRead_data),
	    .EN_startSendRead(spi$EN_startSendRead),
	    .EN_startRead(spi$EN_startRead),
	    .EN_readByte(spi$EN_readByte),
	    .RDY_startSendRead(spi$RDY_startSendRead),
	    .RDY_startRead(spi$RDY_startRead),
	    .readByte(spi$readByte),
	    .RDY_readByte(spi$RDY_readByte),
	    .busy(spi$busy),
	    .sck(spi$sck),
	    .mosi(spi$mosi),
	    .ss(spi$ss));

  // rule RL_initDone
  assign WILL_FIRE_RL_initDone = initialising && !spi$busy ;

  // rule RL_tempDone1
  assign WILL_FIRE_RL_tempDone1 =
	     spi$RDY_startRead && readingTemp && !readingSample &&
	     !spi$busy &&
	     readState == 2'd0 &&
	     adcDone ;

  // rule RL_sampleDone1
  assign WILL_FIRE_RL_sampleDone1 =
	     spi$RDY_startRead && readingSample && !readingTemp &&
	     !spi$busy &&
	     readState == 2'd0 &&
	     adcDone ;

  // rule RL_tempDone2
  assign WILL_FIRE_RL_tempDone2 =
	     spi$RDY_readByte && readingTemp && !readingSample && !spi$busy &&
	     readState == 2'd1 ;

  // rule RL_tempDone3
  assign WILL_FIRE_RL_tempDone3 =
	     spi$RDY_startRead && readingTemp && !readingSample &&
	     !spi$busy &&
	     readState == 2'd2 ;

  // rule RL_tempDone4
  assign WILL_FIRE_RL_tempDone4 =
	     spi$RDY_readByte && readingTemp && !readingSample && !spi$busy &&
	     readState == 2'd3 ;

  // rule RL_sampleDone2
  assign WILL_FIRE_RL_sampleDone2 =
	     spi$RDY_readByte && readingSample && !readingTemp && !spi$busy &&
	     readState == 2'd1 ;

  // rule RL_sampleDone3
  assign WILL_FIRE_RL_sampleDone3 =
	     spi$RDY_startRead && readingSample && !readingTemp &&
	     !spi$busy &&
	     readState == 2'd2 ;

  // rule RL_sampleDone4
  assign WILL_FIRE_RL_sampleDone4 =
	     spi$RDY_readByte && readingSample && !readingTemp && !spi$busy &&
	     readState == 2'd3 ;

  // inputs to muxes for submodule ports
  assign MUX_readState$write_1__SEL_1 =
	     WILL_FIRE_RL_sampleDone4 || WILL_FIRE_RL_tempDone4 ||
	     EN_requestSample ||
	     EN_requestTemp ;
  assign MUX_readState$write_1__SEL_2 =
	     WILL_FIRE_RL_sampleDone1 || WILL_FIRE_RL_tempDone1 ;
  assign MUX_readState$write_1__SEL_3 =
	     WILL_FIRE_RL_sampleDone2 || WILL_FIRE_RL_tempDone2 ;
  assign MUX_readState$write_1__SEL_4 =
	     WILL_FIRE_RL_sampleDone3 || WILL_FIRE_RL_tempDone3 ;
  assign MUX_data$write_1__VAL_1 = { spi$readByte, data[7:0] } ;
  assign MUX_data$write_1__VAL_2 = { data[15:8], spi$readByte } ;
  assign MUX_data$write_1__VAL_3 = { 2'd0, spi$readByte, data[5:0] } ;
  assign MUX_data$write_1__VAL_4 = { data[15:6], spi$readByte[7:2] } ;
  assign MUX_spi$startSendRead_1__VAL_1 =
	     { 1'd1, requestSample_sensor[3:0], 3'd6 } ;

  // register adcDone
  assign adcDone$D_IN = adc_done ;
  assign adcDone$EN = 1'd1 ;

  // register data
  always@(WILL_FIRE_RL_tempDone2 or
	  MUX_data$write_1__VAL_1 or
	  WILL_FIRE_RL_tempDone4 or
	  MUX_data$write_1__VAL_2 or
	  WILL_FIRE_RL_sampleDone2 or
	  MUX_data$write_1__VAL_3 or
	  WILL_FIRE_RL_sampleDone4 or MUX_data$write_1__VAL_4)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_tempDone2: data$D_IN = MUX_data$write_1__VAL_1;
      WILL_FIRE_RL_tempDone4: data$D_IN = MUX_data$write_1__VAL_2;
      WILL_FIRE_RL_sampleDone2: data$D_IN = MUX_data$write_1__VAL_3;
      WILL_FIRE_RL_sampleDone4: data$D_IN = MUX_data$write_1__VAL_4;
      default: data$D_IN = 16'b1010101010101010 /* unspecified value */ ;
    endcase
  end
  assign data$EN =
	     WILL_FIRE_RL_tempDone2 || WILL_FIRE_RL_tempDone4 ||
	     WILL_FIRE_RL_sampleDone2 ||
	     WILL_FIRE_RL_sampleDone4 ;

  // register hasSample
  assign hasSample$D_IN = WILL_FIRE_RL_sampleDone4 ;
  assign hasSample$EN =
	     EN_readSample || EN_requestSample || EN_requestTemp ||
	     WILL_FIRE_RL_sampleDone4 ;

  // register hasTemp
  assign hasTemp$D_IN = WILL_FIRE_RL_tempDone4 ;
  assign hasTemp$EN =
	     EN_readTemp || EN_requestSample || EN_requestTemp ||
	     WILL_FIRE_RL_tempDone4 ;

  // register initialising
  assign initialising$D_IN = !WILL_FIRE_RL_initDone ;
  assign initialising$EN = WILL_FIRE_RL_initDone || EN_init ;

  // register readState
  always@(MUX_readState$write_1__SEL_1 or
	  MUX_readState$write_1__SEL_2 or
	  MUX_readState$write_1__SEL_3 or MUX_readState$write_1__SEL_4)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_readState$write_1__SEL_1: readState$D_IN = 2'd0;
      MUX_readState$write_1__SEL_2: readState$D_IN = 2'd1;
      MUX_readState$write_1__SEL_3: readState$D_IN = 2'd2;
      MUX_readState$write_1__SEL_4: readState$D_IN = 2'd3;
      default: readState$D_IN = 2'b10 /* unspecified value */ ;
    endcase
  end
  assign readState$EN =
	     WILL_FIRE_RL_sampleDone4 || WILL_FIRE_RL_tempDone4 ||
	     EN_requestSample ||
	     EN_requestTemp ||
	     WILL_FIRE_RL_sampleDone1 ||
	     WILL_FIRE_RL_tempDone1 ||
	     WILL_FIRE_RL_sampleDone2 ||
	     WILL_FIRE_RL_tempDone2 ||
	     WILL_FIRE_RL_sampleDone3 ||
	     WILL_FIRE_RL_tempDone3 ;

  // register readingSample
  assign readingSample$D_IN = !WILL_FIRE_RL_sampleDone4 ;
  assign readingSample$EN = WILL_FIRE_RL_sampleDone4 || EN_requestSample ;

  // register readingTemp
  assign readingTemp$D_IN = !WILL_FIRE_RL_tempDone4 ;
  assign readingTemp$EN = WILL_FIRE_RL_tempDone4 || EN_requestTemp ;

  // submodule spi
  assign spi$miso_val = miso_val ;
  always@(EN_requestSample or
	  MUX_spi$startSendRead_1__VAL_1 or EN_init or EN_requestTemp)
  begin
    case (1'b1) // synopsys parallel_case
      EN_requestSample:
	  spi$startSendRead_data = MUX_spi$startSendRead_1__VAL_1;
      EN_init: spi$startSendRead_data = 8'h64;
      EN_requestTemp: spi$startSendRead_data = 8'hF9;
      default: spi$startSendRead_data = 8'b10101010 /* unspecified value */ ;
    endcase
  end
  assign spi$EN_startSendRead =
	     EN_requestSample || EN_init || EN_requestTemp ;
  assign spi$EN_startRead =
	     WILL_FIRE_RL_sampleDone3 || WILL_FIRE_RL_sampleDone1 ||
	     WILL_FIRE_RL_tempDone3 ||
	     WILL_FIRE_RL_tempDone1 ;
  assign spi$EN_readByte =
	     WILL_FIRE_RL_sampleDone4 || WILL_FIRE_RL_sampleDone2 ||
	     WILL_FIRE_RL_tempDone4 ||
	     WILL_FIRE_RL_tempDone2 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        adcDone <= `BSV_ASSIGNMENT_DELAY 1'd0;
	data <= `BSV_ASSIGNMENT_DELAY 16'd0;
	hasSample <= `BSV_ASSIGNMENT_DELAY 1'd0;
	hasTemp <= `BSV_ASSIGNMENT_DELAY 1'd0;
	initialising <= `BSV_ASSIGNMENT_DELAY 1'd0;
	readState <= `BSV_ASSIGNMENT_DELAY 2'd0;
	readingSample <= `BSV_ASSIGNMENT_DELAY 1'd0;
	readingTemp <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (adcDone$EN) adcDone <= `BSV_ASSIGNMENT_DELAY adcDone$D_IN;
	if (data$EN) data <= `BSV_ASSIGNMENT_DELAY data$D_IN;
	if (hasSample$EN) hasSample <= `BSV_ASSIGNMENT_DELAY hasSample$D_IN;
	if (hasTemp$EN) hasTemp <= `BSV_ASSIGNMENT_DELAY hasTemp$D_IN;
	if (initialising$EN)
	  initialising <= `BSV_ASSIGNMENT_DELAY initialising$D_IN;
	if (readState$EN) readState <= `BSV_ASSIGNMENT_DELAY readState$D_IN;
	if (readingSample$EN)
	  readingSample <= `BSV_ASSIGNMENT_DELAY readingSample$D_IN;
	if (readingTemp$EN)
	  readingTemp <= `BSV_ASSIGNMENT_DELAY readingTemp$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    adcDone = 1'h0;
    data = 16'hAAAA;
    hasSample = 1'h0;
    hasTemp = 1'h0;
    initialising = 1'h0;
    readState = 2'h2;
    readingSample = 1'h0;
    readingTemp = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkADC

