//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Fri Aug  2 18:55:22 BST 2013
//
// Method conflict info:
// Method: startSendRead
// Conflict-free: miso, sck, mosi
// Sequenced after: busy, ss
// Sequenced after (restricted): readByte
// Conflicts: startSendRead, startRead
//
// Method: startRead
// Conflict-free: miso, sck, mosi
// Sequenced after: busy, ss
// Sequenced after (restricted): readByte
// Conflicts: startSendRead, startRead
//
// Method: readByte
// Conflict-free: busy, miso, sck, mosi, ss
// Sequenced before (restricted): startSendRead, startRead
// Conflicts: readByte
//
// Method: busy
// Conflict-free: readByte, busy, miso, sck, mosi, ss
// Sequenced before: startSendRead, startRead
//
// Method: miso
// Conflict-free: startSendRead, startRead, readByte, busy, sck, mosi, ss
// Sequenced before (restricted): miso
//
// Method: sck
// Conflict-free: startSendRead, startRead, readByte, busy, miso, sck, mosi, ss
//
// Method: mosi
// Conflict-free: startSendRead, startRead, readByte, busy, miso, sck, mosi, ss
//
// Method: ss
// Conflict-free: readByte, busy, miso, sck, mosi, ss
// Sequenced before: startSendRead, startRead
//
//
// Ports:
// Name                         I/O  size props
// RDY_startSendRead              O     1
// RDY_startRead                  O     1
// readByte                       O     8 reg
// RDY_readByte                   O     1
// busy                           O     1 reg
// sck                            O     1 reg
// mosi                           O     1 reg
// ss                             O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// startSendRead_data             I     8
// miso_val                       I     1 reg
// EN_startSendRead               I     1
// EN_startRead                   I     1
// EN_readByte                    I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkSPI(CLK,
	     RST_N,

	     startSendRead_data,
	     EN_startSendRead,
	     RDY_startSendRead,

	     EN_startRead,
	     RDY_startRead,

	     EN_readByte,
	     readByte,
	     RDY_readByte,

	     busy,

	     miso_val,

	     sck,

	     mosi,

	     ss);
  input  CLK;
  input  RST_N;

  // action method startSendRead
  input  [7 : 0] startSendRead_data;
  input  EN_startSendRead;
  output RDY_startSendRead;

  // action method startRead
  input  EN_startRead;
  output RDY_startRead;

  // actionvalue method readByte
  input  EN_readByte;
  output [7 : 0] readByte;
  output RDY_readByte;

  // value method busy
  output busy;

  // action method miso
  input  miso_val;

  // value method sck
  output sck;

  // value method mosi
  output mosi;

  // value method ss
  output ss;

  // signals for module outputs
  wire [7 : 0] readByte;
  wire RDY_readByte, RDY_startRead, RDY_startSendRead, busy, mosi, sck, ss;

  // register bitCount
  reg [3 : 0] bitCount;
  wire [3 : 0] bitCount$D_IN;
  wire bitCount$EN;

  // register bitIn
  reg bitIn;
  wire bitIn$D_IN, bitIn$EN;

  // register bitOut
  reg bitOut;
  reg bitOut$D_IN;
  wire bitOut$EN;

  // register clkDivide
  reg [3 : 0] clkDivide;
  reg [3 : 0] clkDivide$D_IN;
  wire clkDivide$EN;

  // register clkEnable
  reg clkEnable;
  wire clkEnable$D_IN, clkEnable$EN;

  // register clockDataIn
  reg clockDataIn;
  wire clockDataIn$D_IN, clockDataIn$EN;

  // register clockDataOut
  reg clockDataOut;
  wire clockDataOut$D_IN, clockDataOut$EN;

  // register dataIn
  reg [7 : 0] dataIn;
  wire [7 : 0] dataIn$D_IN;
  wire dataIn$EN;

  // register dataOut
  reg [7 : 0] dataOut;
  wire [7 : 0] dataOut$D_IN;
  wire dataOut$EN;

  // register hasData
  reg hasData;
  wire hasData$D_IN, hasData$EN;

  // register outEnable
  reg outEnable;
  wire outEnable$D_IN, outEnable$EN;

  // register spiClk
  reg spiClk;
  wire spiClk$D_IN, spiClk$EN;

  // register ssTimer
  reg [1 : 0] ssTimer;
  wire [1 : 0] ssTimer$D_IN;
  wire ssTimer$EN;

  // register transferDone
  reg transferDone;
  wire transferDone$D_IN, transferDone$EN;

  // register waitForSS
  reg waitForSS;
  wire waitForSS$D_IN, waitForSS$EN;

  // register working
  reg working;
  wire working$D_IN, working$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_clkCount,
       WILL_FIRE_RL_clkDown,
       WILL_FIRE_RL_clkUp,
       WILL_FIRE_RL_readBit,
       WILL_FIRE_RL_readLastBit,
       WILL_FIRE_RL_sendBit,
       WILL_FIRE_RL_sendLastBit,
       WILL_FIRE_RL_ssWait,
       WILL_FIRE_RL_ssWaitDone,
       WILL_FIRE_RL_transferComplete;

  // inputs to muxes for submodule ports
  wire [7 : 0] MUX_dataIn$write_1__VAL_1, MUX_dataIn$write_1__VAL_2;
  wire [3 : 0] MUX_clkDivide$write_1__VAL_1;
  wire [1 : 0] MUX_ssTimer$write_1__VAL_1;
  wire MUX_bitOut$write_1__VAL_1,
       MUX_clkDivide$write_1__SEL_3,
       MUX_clkEnable$write_1__SEL_1,
       MUX_clockDataIn$write_1__SEL_1,
       MUX_clockDataOut$write_1__SEL_1;

  // remaining internal signals
  wire [7 : 0] x__h1119, y__h1169;
  wire [3 : 0] x__h937;
  wire clkDivide_7_EQ_0_8_AND_NOT_clkEnable_3_5_6_AND_ETC___d68;

  // action method startSendRead
  assign RDY_startSendRead = !working ;

  // action method startRead
  assign RDY_startRead = !working ;

  // actionvalue method readByte
  assign readByte = dataIn ;
  assign RDY_readByte = hasData && !working ;

  // value method busy
  assign busy = working ;

  // value method sck
  assign sck = spiClk ;

  // value method mosi
  assign mosi = bitOut ;

  // value method ss
  assign ss = !outEnable ;

  // rule RL_readBit
  assign WILL_FIRE_RL_readBit =
	     working && clockDataIn && !clockDataOut && bitCount != 4'd0 &&
	     !waitForSS ;

  // rule RL_readLastBit
  assign WILL_FIRE_RL_readLastBit =
	     working && clockDataIn && !clockDataOut && bitCount == 4'd0 &&
	     !waitForSS ;

  // rule RL_sendBit
  assign WILL_FIRE_RL_sendBit =
	     working && clockDataOut && !clockDataIn && bitCount != 4'd0 &&
	     !waitForSS ;

  // rule RL_sendLastBit
  assign WILL_FIRE_RL_sendLastBit =
	     working && clockDataOut && !clockDataIn && bitCount == 4'd0 &&
	     !waitForSS ;

  // rule RL_ssWait
  assign WILL_FIRE_RL_ssWait = waitForSS && working && ssTimer != 2'd0 ;

  // rule RL_clkCount
  assign WILL_FIRE_RL_clkCount = clkDivide != 4'd0 && !transferDone ;

  // rule RL_clkUp
  assign WILL_FIRE_RL_clkUp =
	     clkDivide == 4'd0 && clkEnable && !spiClk && !clockDataIn &&
	     !clockDataOut &&
	     !transferDone ;

  // rule RL_clkDown
  assign WILL_FIRE_RL_clkDown =
	     clkDivide == 4'd0 && clkEnable && spiClk && !clockDataIn &&
	     !clockDataOut &&
	     !transferDone ;

  // rule RL_ssWaitDone
  assign WILL_FIRE_RL_ssWaitDone = waitForSS && working && ssTimer == 2'd0 ;

  // rule RL_transferComplete
  assign WILL_FIRE_RL_transferComplete = transferDone && working ;

  // inputs to muxes for submodule ports
  assign MUX_clkDivide$write_1__SEL_3 =
	     WILL_FIRE_RL_clkDown || WILL_FIRE_RL_clkUp ;
  assign MUX_clkEnable$write_1__SEL_1 =
	     WILL_FIRE_RL_readLastBit || WILL_FIRE_RL_sendLastBit ;
  assign MUX_clockDataIn$write_1__SEL_1 =
	     WILL_FIRE_RL_readLastBit || WILL_FIRE_RL_readBit ;
  assign MUX_clockDataOut$write_1__SEL_1 =
	     WILL_FIRE_RL_sendLastBit || WILL_FIRE_RL_sendBit ;
  assign MUX_bitOut$write_1__VAL_1 = dataOut[x__h937[2:0]] ;
  assign MUX_clkDivide$write_1__VAL_1 = clkDivide - 4'd1 ;
  assign MUX_dataIn$write_1__VAL_1 =
	     bitIn ? dataIn | x__h1119 : dataIn & y__h1169 ;
  assign MUX_dataIn$write_1__VAL_2 = { dataIn[7:1], bitIn } ;
  assign MUX_ssTimer$write_1__VAL_1 = ssTimer - 2'd1 ;

  // register bitCount
  assign bitCount$D_IN = WILL_FIRE_RL_readBit ? x__h937 : 4'd8 ;
  assign bitCount$EN = WILL_FIRE_RL_readBit || WILL_FIRE_RL_ssWaitDone ;

  // register bitIn
  assign bitIn$D_IN = miso_val ;
  assign bitIn$EN = 1'd1 ;

  // register bitOut
  always@(WILL_FIRE_RL_sendBit or
	  MUX_bitOut$write_1__VAL_1 or
	  WILL_FIRE_RL_sendLastBit or dataOut or WILL_FIRE_RL_ssWaitDone)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_sendBit: bitOut$D_IN = MUX_bitOut$write_1__VAL_1;
      WILL_FIRE_RL_sendLastBit: bitOut$D_IN = dataOut[0];
      WILL_FIRE_RL_ssWaitDone: bitOut$D_IN = dataOut[7];
      default: bitOut$D_IN = 1'b0 /* unspecified value */ ;
    endcase
  end
  assign bitOut$EN =
	     WILL_FIRE_RL_sendBit || WILL_FIRE_RL_sendLastBit ||
	     WILL_FIRE_RL_ssWaitDone ;

  // register clkDivide
  always@(WILL_FIRE_RL_clkCount or
	  MUX_clkDivide$write_1__VAL_1 or
	  WILL_FIRE_RL_transferComplete or MUX_clkDivide$write_1__SEL_3)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_clkCount: clkDivide$D_IN = MUX_clkDivide$write_1__VAL_1;
      WILL_FIRE_RL_transferComplete: clkDivide$D_IN = 4'd0;
      MUX_clkDivide$write_1__SEL_3: clkDivide$D_IN = 4'd15;
      default: clkDivide$D_IN = 4'b1010 /* unspecified value */ ;
    endcase
  end
  assign clkDivide$EN =
	     WILL_FIRE_RL_clkCount || WILL_FIRE_RL_transferComplete ||
	     WILL_FIRE_RL_clkDown ||
	     WILL_FIRE_RL_clkUp ;

  // register clkEnable
  assign clkEnable$D_IN = !MUX_clkEnable$write_1__SEL_1 ;
  assign clkEnable$EN =
	     WILL_FIRE_RL_readLastBit || WILL_FIRE_RL_sendLastBit ||
	     WILL_FIRE_RL_ssWaitDone ;

  // register clockDataIn
  assign clockDataIn$D_IN = !MUX_clockDataIn$write_1__SEL_1 ;
  assign clockDataIn$EN =
	     WILL_FIRE_RL_readLastBit || WILL_FIRE_RL_readBit ||
	     WILL_FIRE_RL_clkUp ;

  // register clockDataOut
  assign clockDataOut$D_IN = !MUX_clockDataOut$write_1__SEL_1 ;
  assign clockDataOut$EN =
	     WILL_FIRE_RL_sendLastBit || WILL_FIRE_RL_sendBit ||
	     WILL_FIRE_RL_clkDown ;

  // register dataIn
  assign dataIn$D_IN =
	     WILL_FIRE_RL_readBit ?
	       MUX_dataIn$write_1__VAL_1 :
	       MUX_dataIn$write_1__VAL_2 ;
  assign dataIn$EN = WILL_FIRE_RL_readBit || WILL_FIRE_RL_readLastBit ;

  // register dataOut
  assign dataOut$D_IN = EN_startSendRead ? startSendRead_data : 8'd0 ;
  assign dataOut$EN = EN_startSendRead || EN_startRead ;

  // register hasData
  assign hasData$D_IN = WILL_FIRE_RL_transferComplete ;
  assign hasData$EN =
	     EN_readByte || EN_startRead || EN_startSendRead ||
	     WILL_FIRE_RL_transferComplete ;

  // register outEnable
  assign outEnable$D_IN = !WILL_FIRE_RL_transferComplete ;
  assign outEnable$EN =
	     WILL_FIRE_RL_transferComplete || EN_startRead ||
	     EN_startSendRead ;

  // register spiClk
  assign spiClk$D_IN = !WILL_FIRE_RL_clkDown ;
  assign spiClk$EN = MUX_clkDivide$write_1__SEL_3 ;

  // register ssTimer
  assign ssTimer$D_IN =
	     WILL_FIRE_RL_ssWait ? MUX_ssTimer$write_1__VAL_1 : 2'd3 ;
  assign ssTimer$EN =
	     WILL_FIRE_RL_ssWait || EN_startRead || EN_startSendRead ;

  // register transferDone
  assign transferDone$D_IN = !WILL_FIRE_RL_transferComplete ;
  assign transferDone$EN =
	     WILL_FIRE_RL_transferComplete ||
	     clkDivide_7_EQ_0_8_AND_NOT_clkEnable_3_5_6_AND_ETC___d68 &&
	     working &&
	     !waitForSS ;

  // register waitForSS
  assign waitForSS$D_IN = !WILL_FIRE_RL_ssWaitDone ;
  assign waitForSS$EN =
	     WILL_FIRE_RL_ssWaitDone || EN_startRead || EN_startSendRead ;

  // register working
  assign working$D_IN = !WILL_FIRE_RL_transferComplete ;
  assign working$EN =
	     WILL_FIRE_RL_transferComplete || EN_startRead ||
	     EN_startSendRead ;

  // remaining internal signals
  assign clkDivide_7_EQ_0_8_AND_NOT_clkEnable_3_5_6_AND_ETC___d68 =
	     clkDivide == 4'd0 && !clkEnable && !transferDone &&
	     bitCount == 4'd0 ;
  assign x__h1119 = 8'd1 << x__h937 ;
  assign x__h937 = bitCount - 4'd1 ;
  assign y__h1169 = ~x__h1119 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        bitCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
	bitIn <= `BSV_ASSIGNMENT_DELAY 1'd0;
	bitOut <= `BSV_ASSIGNMENT_DELAY 1'd0;
	clkDivide <= `BSV_ASSIGNMENT_DELAY 4'd0;
	clkEnable <= `BSV_ASSIGNMENT_DELAY 1'd0;
	clockDataIn <= `BSV_ASSIGNMENT_DELAY 1'd0;
	clockDataOut <= `BSV_ASSIGNMENT_DELAY 1'd0;
	dataIn <= `BSV_ASSIGNMENT_DELAY 8'd0;
	dataOut <= `BSV_ASSIGNMENT_DELAY 8'd0;
	hasData <= `BSV_ASSIGNMENT_DELAY 1'd0;
	outEnable <= `BSV_ASSIGNMENT_DELAY 1'd0;
	spiClk <= `BSV_ASSIGNMENT_DELAY 1'd0;
	ssTimer <= `BSV_ASSIGNMENT_DELAY 2'd0;
	transferDone <= `BSV_ASSIGNMENT_DELAY 1'd0;
	waitForSS <= `BSV_ASSIGNMENT_DELAY 1'd0;
	working <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (bitCount$EN) bitCount <= `BSV_ASSIGNMENT_DELAY bitCount$D_IN;
	if (bitIn$EN) bitIn <= `BSV_ASSIGNMENT_DELAY bitIn$D_IN;
	if (bitOut$EN) bitOut <= `BSV_ASSIGNMENT_DELAY bitOut$D_IN;
	if (clkDivide$EN) clkDivide <= `BSV_ASSIGNMENT_DELAY clkDivide$D_IN;
	if (clkEnable$EN) clkEnable <= `BSV_ASSIGNMENT_DELAY clkEnable$D_IN;
	if (clockDataIn$EN)
	  clockDataIn <= `BSV_ASSIGNMENT_DELAY clockDataIn$D_IN;
	if (clockDataOut$EN)
	  clockDataOut <= `BSV_ASSIGNMENT_DELAY clockDataOut$D_IN;
	if (dataIn$EN) dataIn <= `BSV_ASSIGNMENT_DELAY dataIn$D_IN;
	if (dataOut$EN) dataOut <= `BSV_ASSIGNMENT_DELAY dataOut$D_IN;
	if (hasData$EN) hasData <= `BSV_ASSIGNMENT_DELAY hasData$D_IN;
	if (outEnable$EN) outEnable <= `BSV_ASSIGNMENT_DELAY outEnable$D_IN;
	if (spiClk$EN) spiClk <= `BSV_ASSIGNMENT_DELAY spiClk$D_IN;
	if (ssTimer$EN) ssTimer <= `BSV_ASSIGNMENT_DELAY ssTimer$D_IN;
	if (transferDone$EN)
	  transferDone <= `BSV_ASSIGNMENT_DELAY transferDone$D_IN;
	if (waitForSS$EN) waitForSS <= `BSV_ASSIGNMENT_DELAY waitForSS$D_IN;
	if (working$EN) working <= `BSV_ASSIGNMENT_DELAY working$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    bitCount = 4'hA;
    bitIn = 1'h0;
    bitOut = 1'h0;
    clkDivide = 4'hA;
    clkEnable = 1'h0;
    clockDataIn = 1'h0;
    clockDataOut = 1'h0;
    dataIn = 8'hAA;
    dataOut = 8'hAA;
    hasData = 1'h0;
    outEnable = 1'h0;
    spiClk = 1'h0;
    ssTimer = 2'h2;
    transferDone = 1'h0;
    waitForSS = 1'h0;
    working = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkSPI

